import { CSSProperties, Dispatch, FC, HTMLProps, MutableRefObject, ReactChild, ReactChildren, ReactNode, SetStateAction } from 'react';
import { Control, DeepPartial, FieldErrors, FieldNamesMarkedBoolean, Mode, Path, PathValue, UseFormGetValues, UseFormReset } from 'react-hook-form/dist/types';
import { ObjectSchema, AnyObjectSchema, AnySchema } from 'yup';
import { GroupedOptionsType, OptionsType } from 'react-select';
import { GridAreaProps } from 'Grid';
import { CheckOption, FormDateRangeValue, FormValue, MessageType, SelectOption } from 'types';
import { ObjectShape } from 'yup/lib/object';
export type GridMode = 'viewport' | 'container' | 'slim';
export interface Locked {
    initial?: boolean;
    unlockable?: boolean;
    readOnly?: boolean;
}
export type MultiFieldValues = {
    name: string;
    values: Option[];
};
export interface FieldProps<I extends Record<string, unknown>, N = BaseFieldType> {
    field: Field<I, N>;
    name: Path<I>;
    children?: ReactChildren | ReactChild;
    index?: number;
    defaultValue?: string | number | readonly string[] | FormDateRangeValue | boolean | undefined;
    loadName?: string;
    parentName?: string;
    loadOptions?: (inputValue: string) => Promise<SelectOption[]>;
    isDeleting?: boolean;
}
export interface ActionProps<I extends Record<string, unknown>, N = BaseFieldType> {
    field: Field<I, N>;
    action: Action<I, N>;
}
export interface StyledComponents {
    header?: CSSProperties;
    footer?: CSSProperties;
    pagination?: CSSProperties;
    paginationContainer?: CSSProperties;
    section?: CSSProperties;
}
export interface ConfirmationSchema {
    success: boolean | string;
    successModal?: ConfirmationModalSchema;
    cancel: boolean | string;
    cancelModal?: ConfirmationModalSchema;
}
export interface ConfirmationModalSchema {
    title?: string;
    messageType?: MessageType;
    cancelButtonText?: string;
    acceptButtonText?: string;
}
export type Breakpoint = 'slim' | 'small' | 'medium' | 'large';
export interface PaginationSchema {
    hideBreakpoints: Breakpoint[];
}
export type LabelOverrides = 'bulk.single' | 'bulk.bulk';
export interface FormDisplay {
    feedback: {
        reserveSpace: boolean;
    };
}
export type ToolbarPlacement = 'none' | 'top' | 'bottom';
export interface ToolbarPlacementSettings {
    [x: string]: ToolbarPlacement;
}
export interface ToolbarSchema {
    actions?: string[];
    location: ToolbarPlacement | ToolbarPlacementSettings;
    hideCleanCancel?: boolean;
}
export interface HeaderSchema {
    isSticky?: boolean;
    areTabsSticky?: boolean;
}
export interface FooterSchema {
    isSticky?: boolean;
}
export type FormAsyncActions = 'saveDraft' | 'submit';
export interface FormSchema<I extends Record<string, unknown>, N = BaseFieldType> {
    display?: Partial<FormDisplay>;
    saveButton?: string;
    cancelButton?: string;
    saveDraftButton?: string;
    defaultValues?: Partial<I>;
    visibleFields?: (keyof I)[];
    enabledFields?: (keyof I)[];
    pages?: Page[];
    name?: string;
    confirmation?: ConfirmationSchema;
    pagination?: PaginationSchema;
    description?: string;
    defaultFieldSize?: Size;
    header?: HeaderSchema;
    footer?: FooterSchema;
    toolbar?: ToolbarSchema | ToolbarPlacement | ToolbarPlacementSettings;
    fields?: Field<I, N>[];
    styles?: StyledComponents;
    labels?: {
        [Property in keyof LabelOverrides]: string;
    };
    drafts?: {
        validate?: boolean;
    };
}
export type ParseSchemaState<I extends Record<string, unknown>, N = BaseFieldType> = Pick<FormContext<I, N>, 'fieldMap' | 'fieldRef'> & {
    defaultValues: Record<string, unknown>;
    validationSchema: ObjectShape;
};
export type SchemaState<I extends Record<string, unknown>, N = BaseFieldType> = Pick<FormContext<I, N>, 'defaultValues' | 'fieldMap' | 'fieldRef'> & {
    validationSchema: AnyObjectSchema;
};
export interface FieldMap<I extends Record<string, unknown>, N = BaseFieldType> extends Field<I, N> {
    visible: boolean;
    parent?: Field<I, N>;
}
export interface FormContext<I extends Record<string, unknown>, N = BaseFieldType> {
    hash: string;
    form: FormSchema<I, N>;
    formId: string;
    options: FormOptions<I, N>;
    fieldRef: Record<string, Field<I, N>>;
    fieldMap: FieldMap<I, N>[];
    defaultValues: DeepPartial<I> | undefined;
    validationSchema: ObjectSchema<ObjectShape>;
    utils: {
        calculateSizes: (field: Field<I, N>) => GridAreaProps;
        isVisible: (field: Field<I, N>) => boolean;
        isEditable: (field: Field<I, N>) => boolean;
        setCurrentPage: Dispatch<SetStateAction<string | boolean>>;
        configureTable: (field: Field<I, N>) => void;
    };
    values: DeepPartial<I>;
    currentPage: string | false;
    isValid: boolean;
    isDirty: boolean;
    dirtyFields: FieldNamesMarkedBoolean<I>;
    errors: FieldErrors<I>;
    reset: UseFormReset<I>;
    onCancel: () => void;
    resetOnCancel: boolean;
    formLocked: boolean;
    formUnlockable: boolean;
    setFormLocked: (locked: boolean) => void;
    screenSize: FormGeneratorSize;
    actionRunning?: FormAsyncActions;
    isSubmittable: boolean;
    gridMode: GridMode;
    control: Control<I>;
    repeaterSettings: Record<keyof I, Record<string, unknown>>;
    revalidationMode: Exclude<Mode, 'onTouched' | 'all'>;
    locked: Locked;
    currentBreakpoint: Breakpoint;
    setSavingDraft: (savingDraft: boolean) => void;
    onSaveDraft: FormGeneratorSubmit<I>;
}
export interface FormResolverContext<I extends Record<string, unknown>, N = BaseFieldType> {
    currentPage: string;
    options: FormOptions<I, N>;
    gridMode: GridMode;
    screenSize: FormGeneratorSize;
    breakpoint: Breakpoint;
    savingDraftRef: MutableRefObject<boolean>;
    getFormValuesRef: MutableRefObject<UseFormGetValues<I>>;
}
export interface Option {
    value: string;
    label: string;
    isDisabled?: boolean;
}
export interface CheckboxFieldOption extends CheckOption {
    readonly?: boolean;
}
export type Options = OptionsType<Option> | GroupedOptionsType<Option>;
export interface ToggleSwitchOption {
    value?: string;
    label?: string;
    icon?: string;
    iconOnly?: boolean;
    readonly?: boolean;
}
export type Fields<I extends Record<string, unknown>, N = BaseFieldType> = Field<I, N>[];
export interface TableSettings {
    mode: 'bulk' | 'single';
}
export interface Field<I extends Record<string, unknown>, N = BaseFieldType> {
    name: Path<I>;
    type: FieldType<N>;
    label?: string;
    tooltip?: string[];
    columnSize?: string;
    description?: string;
    subdescription?: string;
    fileSize?: number;
    accept?: string;
    multiple?: boolean;
    size?: number | Size;
    readonly?: boolean;
    disabled?: boolean;
    placeholder?: string;
    class?: string;
    value?: unknown;
    watch?: string | string[];
    clearable?: boolean;
    collapsible?: boolean;
    creatable?: boolean;
    async?: boolean;
    bulkAdd?: boolean;
    portal?: string;
    rowRequired?: boolean;
    layout?: string;
    mask?: {
        input: string;
        character?: string;
        alwaysShow?: boolean;
    };
    options?: ReadonlyArray<Option> | ReadonlyArray<CheckboxFieldOption> | ReadonlyArray<ToggleSwitchOption>;
    visibility?: {
        action: ConditionalAction;
        logic: ConditionalLogic;
        rules: Rule[];
    };
    editable?: {
        action: EditableAction;
        logic: ConditionalLogic;
        rules: Rule[];
    };
    enabled?: {
        action: EnabledAction;
        logic: ConditionalLogic;
        rules: Rule[];
    };
    validator?: (FieldValidator | string)[];
    fields?: Field<I, N>[];
    /**
     * Control text overflow behavior for readonly field.
     * truncate hide overflowed text, add ellipsis and display complete text on hover,
     * wrap to wrap text.
     */
    truncate?: 'truncate' | 'wrap';
    page?: string;
    rows?: number;
    mode?: string;
    max?: number;
    min?: number;
    charCount?: boolean;
    step?: number | 'any';
    detached?: boolean;
    actions?: Action<I, N>[];
    blockScrollWhenOpen?: boolean;
    closeMenuOnScroll?: boolean;
    showSelectAllOption?: boolean;
    deleteEntryConfirmationModal?: {
        title: string;
        text: string;
    };
    customGetErrorMessage?: (errors: FieldErrors<I>, values: I) => ReactNode;
    customIsErrorValidation?: (errors: FieldErrors<I>, values: I) => boolean;
}
export type ActionType = 'bulk' | 'field' | 'clear';
export interface Action<I extends Record<string, unknown>, N = BaseFieldType> {
    type: ActionType;
    field?: Field<I, N>;
}
export interface FieldValidator {
    type: string;
    value?: number | string | RegExp;
    meta?: FieldValidatorMeta;
    message?: string;
}
export interface FieldValidatorMeta {
    [x: string]: unknown;
    dependentFieldValue?: null | string | number | Option | Option[];
    dependentFieldNull?: boolean;
    dependentField?: string;
    titleName?: string;
}
export type EditableAction = 'editable' | 'readonly';
export type EnabledAction = 'enabled' | 'disabled';
export type ConditionalAction = 'show' | 'hide';
export type ConditionalLogic = 'all' | 'any';
export interface RuleDateConfig {
    format?: string;
}
export interface Rule {
    field: string;
    operator: Operator;
    value?: string | number | SelectOption | SelectOption[];
    date?: RuleDateConfig;
}
export type Operator = 'empty' | 'notempty' | 'equal' | 'notequal' | 'contain' | 'notcontain' | '>' | '>=' | '<' | '<=';
export interface CalculatedSize {
    slim: number;
    small: number;
    medium: number;
    large: number;
}
export interface Size {
    slim?: number;
    small?: number;
    medium?: number;
    large?: number;
}
export type BaseFieldType = 'section' | 'input' | 'number' | 'select' | 'multiselect' | 'date' | 'checkbox' | 'radio' | 'markdown' | 'textarea' | 'toggle' | 'multiselectpopout' | 'toggleswitch' | 'hidden' | 'tablerepeater' | 'display' | 'filemanager' | 'upload' | 'readonly' | 'inputmask' | 'daterange';
export type FieldType<N> = BaseFieldType | N;
export interface Page {
    name: string;
    label: string;
}
export interface Validator<I extends Record<string, unknown>, N = BaseFieldType> {
    [key: string]: (field: Field<I, N>, yup: AnySchema, validator: FieldValidator) => AnySchema;
}
export interface CustomFieldType {
    [key: string]: ReactNode;
}
export type DefaultValueType = string | number | boolean | undefined | Record<string, unknown>[] | null;
export interface CustomFieldDefaultValueType {
    [key: string]: DefaultValueType;
}
export interface CustomActionType {
    [key: string]: ReactNode;
}
export interface ToolbarActionType {
    [key: string]: FC<HTMLProps<HTMLButtonElement>>;
}
export interface CustomPortalType {
    [key: string]: HTMLElement;
}
export interface CustomComponents {
    header?: ReactNode;
    footer?: ReactNode;
    titlebar?: ReactNode;
    toolbar?: ReactNode;
    headerWrapper?: ReactNode;
    footerWrapper?: ReactNode;
    contentWrapper?: ReactNode;
    bodyWrapper?: ReactNode;
    repeaterDelete?: ReactNode;
    repeaterAdd?: ReactNode;
    cancel?: ReactNode;
    saveDraft?: ReactNode;
    submit?: ReactNode;
}
export interface FormOptions<I extends Record<string, unknown>, N = BaseFieldType> {
    display: FormDisplay;
    labels: Record<string, string>;
    styles: StyledComponents;
    pages: Page[] | false;
    defaultValues: DeepPartial<I> | undefined;
    visibleFields: (keyof I)[] | undefined;
    enabledFields: (keyof I)[] | undefined;
    defaultFieldSize: CalculatedSize;
    portals: CustomPortalType;
    form: FormSchema<I, N>;
    formName: string;
    header: HeaderSchema;
    footer: FooterSchema;
    toolbar: ToolbarSchema;
    formDescription: string;
    saveButton: string;
    cancelButton: string | boolean;
    saveDraftButton: string;
    components: {
        header: ReactNode;
        footer: ReactNode;
        titlebar: ReactNode;
        toolbar: ReactNode;
        headerWrapper: ReactNode;
        footerWrapper: ReactNode;
        bodyWrapper: ReactNode;
        contentWrapper: ReactNode;
        repeaterDelete: ReactNode;
        repeaterAdd: ReactNode;
        cancel: ReactNode;
        saveDraft: ReactNode;
        submit: ReactNode;
    };
    fieldTypes: CustomFieldType;
    fieldTypeDefaultValues: CustomFieldDefaultValueType;
    actions: CustomActionType;
    validators: ValidatorOptions<I, N>;
    customToolbarActions: CustomActionType;
    drafts?: {
        validate?: boolean;
    };
}
export type ValidatorOptions<I extends Record<string, unknown>, N = BaseFieldType> = Validator<I, N> & {
    required: (field: Field<I, N>, yup: AnySchema, validator: FieldValidator) => AnySchema;
    min: (field: Field<I, N>, yup: AnySchema, validator: FieldValidator) => AnySchema;
    max: (field: Field<I, N>, yup: AnySchema, validator: FieldValidator) => AnySchema;
};
export interface PageState {
    pages: Page[];
    errorPages: string[];
    dirtyPages: string[];
}
export interface FormGeneratorSize {
    viewport: {
        innerHeight: number;
        innerWidth: number;
    };
    container: {
        innerHeight: number;
        innerWidth: number;
    };
}
export interface FieldContext {
    value: string;
    type: string;
}
export type LoadDataFunc<I extends Record<string, unknown>> = (formValues: DeepPartial<I>, rowValues?: Record<string, FormValue>, fieldsContext?: FieldContext) => Promise<Options | MultiFieldValues[]>;
export type SetValueFunc<I extends Record<string, unknown>> = (currentValue: PathValue<I, Path<I>>, watchedFieldValue: PathValue<I, Path<I>> | unknown, values: I) => PathValue<I, Path<I>>;
export type FormGeneratorSubmit<I extends Record<string, unknown>> = (data: I, context?: SubmitContext<I>) => any | Promise<any>;
export interface SubmitContext<I extends Record<string, unknown>> {
    visibleFields: Record<string, any>;
    enabledFields: Record<string, any>;
    dirtyFields: FieldNamesMarkedBoolean<I>;
}
export interface AsyncTransportFunc<I extends Record<string, unknown>> {
    load?: (formValues: DeepPartial<I>) => Promise<any>;
    save?: (values: any, formValues: DeepPartial<I>) => Promise<any>;
    delete?: (value: any, formValues: DeepPartial<I>) => Promise<any>;
    updateValue?: SetValueFunc<I>;
    createRows?: (values: any) => Promise<Record<string, unknown>>;
}
export type FormFieldValue = null | boolean | string | number | Option | Option[];
